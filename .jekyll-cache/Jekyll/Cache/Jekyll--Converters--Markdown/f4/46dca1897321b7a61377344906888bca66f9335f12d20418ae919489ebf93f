I"<p>우아한 테크코스 3기를 지원했다. 사실 지원하고 1차 온라인 코딩 테스트는 지난주 주말에 치뤘는데, 블로그 정비를 하다보니 후기가 늦어졌다. 원래도 1차 코딩 테스트는 크게 어렵지 않다고 들었기 때문에 많이 긴장하지는 않았는데, 열심히 준비하긴했다..ㅎㅎ 어쨌든, 이번 포스팅에서는 왜 우아한 테크코스에 지원했고, 1차 온라인 코딩 테스트가 어땠는지에 대한 후기를 한 번 풀어보려한다.<br />
<br />
<br /></p>

<h2 id="1-지원-동기">1. 지원 동기</h2>

<p>사실 교육 기간 10개월이라는 이야기를 들었을때 지원을 할까말까 많이 고민했었다. 하지만 현재 같은 분야에 종사하고 있는 친언니와 이야기하면서 취업전 좋은 기회가 될거라고 생각이 바뀌었고, 열심히 자소서를 작성해서 지원하게 되었다. 추가로, 지인이 이번에 우아한 형제들에 입사하게 되었는데 여러가지 정보를 들으면서 입사하고픈 마음이 커져 그 영향도 없었다고는 못하겠다 😌
<br /><br /><br /></p>

<h2 id="2-1차-온라인-코딩-테스트">2. 1차 온라인 코딩 테스트</h2>

<p>1차 온라인 코딩 테스트를 준비하면서 자신감도 생기고 푸는 문제가 늘어가면서 약간의 자만심도 함께 생긴것 같다. 코딩 테스트 보기 하루 전, 우아한 테크코스 1기 온라인 테스트 문제들을 풀어보면서 난이도는 쉬운편이라고 생각했는데, 문자열을 다루는 문제가 많았다. 나는 문자열을 다루는건 익숙하지 않아 그 부분을 중점적으로 준비했다.</p>

<p>1차 온라인 코딩 테스트는 오후 12시부터 4시까지 4시간동안 코딩 테스트를 치뤘다. 시간이 조금 남아 내 코드를 전체적으로 한 번더 확인하고 문제와 내 코드도 정리해두었으나, 문제 유출은 금지이기 때문에 어떤 문제인지는 밝히지 못하는 점 양해해주길 바란다.</p>

<h3 id="문제-1">문제 1.</h3>

<p>정말 간단한 문제라 보자마자 풀었다. 그냥 문제에서 이야기하는 것을 거의 그대로 코드로만 구현하면 되는 문제였다.</p>

<ul>
  <li>맵을 사용해서 미리 문제에서 제공하는 정보를 저장해두고, 문제에서 요구하는 것에 맞게 계산하여 답을 반환하였다.</li>
  <li>시간 복잡도는 O(n)으로 풀었다. 이것보다 더 효율성 좋게 풀 수는 없을 것 같다..
<br /><br /></li>
</ul>

<h3 id="문제-2">문제 2.</h3>

<p>이 문제도 크게 어렵지는 않았다. 다만 약간의 함정이 있었다면 입력 데이터의 길이가 2에서 10까지였기 때문에 문제에서 요구하는 것을 구현한 후의 답이 int를 충분히 벗어날 수 있는 크기였다는 점이다.</p>

<ul>
  <li>long long 타입의 백터를 답으로 두고, 입력 데이터의 길이 만큼 반복문을 돌면서 문제에서 요구하는 것에 맞게 계산한 답을 벡터에 푸시한 후 답을 반환했다.</li>
  <li>시간 복잡도는 입력 데이터의 길이를 n이라 했을 때 O(n)으로 풀었다. 이 또한 더 효율성 좋게 풀 수는 없을 것 같다.
<br /><br /></li>
</ul>

<h3 id="문제-3">문제 3.</h3>

<p>이 문제 또한 크게 어렵지 않았다. 역시 문제에서 요구하는 것을 그대로 구현하면 되는 문제였고, 문제 2와 마찬가지로 약간의 함정이 있는 문제였다. 문제만 잘 읽었으면 크게 혼란을 주는 문제는 아니었다.</p>

<ul>
  <li>베팅 하려는 금액을 정수로 두고 초기값을 잘 설정해주고, 입력 데이터 크기만큼 반복문을 돌면서 문제에서 요구하는 것에 맞게 구현하여 답을 반환했다.</li>
  <li>시간 복잡도는 O(n)으로 풀었다. 이것도 이보다 더 효율성 좋게 풀 수 없을 것으로 보인다..
<br /><br /></li>
</ul>

<h3 id="문제-4">문제 4.</h3>

<p>이 문제는 어렵거나 함정이 있다기 보다는, 말 그대로 구현 문제라서 어떻게 자신이 논리를 잘 세워서 구현했느냐가 중요한 문제라고 생각한다. 나는 전에 비슷한 문제를 풀어보았기 때문에 금방 생각할 수 있었다.</p>

<ul>
  <li>처음에 입력으로 받은 데이터를 한 번 재가공해 저장하고, 1부터 \(n^2\)까지 반복문으로 돌면서 문제에서 요구하는 것에 맞게 구현하여 답을 반환했다.</li>
  <li>해당 문제의 시간 복잡도는 주어진 2차원 배열의 입력 데이터를 \(n^2\)라 했을 때 O(\(n^2\))로 풀었다. 더 효율성 좋게 풀 방법이 딱히 없을 것 같다.
<br /><br /></li>
</ul>

<h3 id="문제-5">문제 5.</h3>

<p>이 문제도 전혀 어려운 문제가 아니었다. 이전 문제들과 비슷하게 요구하는 것을 그대로 구현하면 되는 문제였다.</p>

<ul>
  <li>답을 나타내는 문자열을 한 개 생성해서 입력으로 받은 데이터를 반복문으로 돌면서 문제에서 요구하는 것에 맞게 데이터를 가공하여 답을 반환했다.</li>
  <li>시간 복잡도는 주어진 데이터 문자열의 길이를 n이라고 했을 때 처리해야하는 문자열 단위마다 다르겠지만 최악의 경우에 O(n)이 된다. 이 또한 더 효율성 좋게 풀 방법이 딱히 생각나지는 않는다.
<br /><br /></li>
</ul>

<h3 id="문제-6">문제 6.</h3>

<p>이 문제부터 조금 고민을 해야했던 문제였다. 사실 문제를 어떻게 풀어야할지 접근조차 못할 정도는 아니었는데, 더 효율성 좋게 풀 방법이 생각나지는 않았던 것 같다. 그리고 문제를 다 풀고 마지막에 확인하다가 내가 놓쳤던 부분이 점수가 0 점인 경우도 문제를 풀었다고 가정한다는 부분에 대해서 잘못풀었어서 그 부분도 수정하고 다시 제출했다.</p>

<ul>
  <li>맵을 사용해서 풀었는데, key 값으로 문자열, value 값으로 또다른 맵을 구성하는 자료구조를 사용했다. 처음에 입력 데이터를 가공해서 맵에 원하는 형태로 저장하고 세 개의 중첩 반복문을 돌면서 같은지를 확인하는 식으로 풀었다.</li>
  <li>시간 복잡도는 O(\(n^3\))으로 풀었다. 분명 더 좋은 방법이 있을 것 같기도 한데, 문제 풀 당시에는 떠오르지 않아 일단 정확하게 푸는게 먼저라고 생각했기 때문에 그냥 풀었다…</li>
</ul>

<p><br /><br /></p>

<h3 id="문제-7">문제 7.</h3>

<p>이 문제는 처음에 봤을때 지금까지 풀어보았던 문제랑은 조금 달라서 상대적으로 고민을 많이 했던 문제였다. 약간 막막했다가 생각을 한 후 풀어냈는데, 효율성 면에서나 크게 자신이 있는 문제는 아니다.</p>

<ul>
  <li>시간 복잡도는 주어진 데이터 가로, 세로 길이가 n이라고 할 때, O()
<br /><br /></li>
</ul>

<h2 id="4-느낀점">4. 느낀점</h2>

<p>제발 붙길…!🙏🏻🙏🏻
<br /><br /><br /></p>
:ET