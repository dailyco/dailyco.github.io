I"<p>난이도 ★ ★ ☆ ☆ ☆<br />
본 문제는 풀기 전에 알고리즘을 생각하면서 ‘이렇게하면 될까?’하고 반신반의하며 푼 문제이다. set의 upper_bound에 대해서 제대로 이해하지 못하고 있는 줄 알았는데 막상 이걸 이용해서 문제를 해결하고나니 제대로 이해하고 있었다는 생각이 들었다 :)<br />
<br /></p>

<p><br /></p>

<h2 id="1-문제">1. 문제</h2>
<p>전화번호부에 적힌 전화번호 중, 한 번호가 다른 번호의 접두어인 경우가 있는지 확인하려 합니다.<br />
전화번호가 다음과 같을 경우, 구조대 전화번호는 영석이의 전화번호의 접두사입니다.</p>
<ul>
  <li>구조대 : 119</li>
  <li>박준영 : 97 674 223</li>
  <li>지영석 : 11 9552 4421</li>
</ul>

<p>전화번호부에 적힌 전화번호를 담은 배열 phone_book 이 solution 함수의 매개변수로 주어질 때, 어떤 번호가 다른 번호의 접두어인 경우가 있으면 false를 그렇지 않으면 true를 return 하도록 solution 함수를 작성해주세요.</p>

<h3 id="제한조건">제한조건</h3>
<ul>
  <li>phone_book의 길이는 1 이상 1,000,000 이하입니다.</li>
  <li>각 전화번호의 길이는 1 이상 20 이하입니다.
<br /><br /><br /></li>
</ul>

<h2 id="2-알고리즘-생각해보자">2. 알고리즘! 생각해보자</h2>
<ol>
  <li>phone_book의 원소를 모두 set에 담는다.</li>
  <li>set에서 각 phone_book 원소의 upper bound를 찾는다.<br />
(upper bound는 해당 값을 가지는 맨 마지막 원소를 가르킨다)</li>
  <li>upper bound가 마지막 원소일 경우는 pass한다.</li>
  <li>각 phone_book 원소가 해당 upper_bound의 접두어인지 확인한다.<br />
(find() 함수를 사용해서 해당 문자열을 찾지못하면 -1(npos), 찾으면 위치 인덱스를 반환하는 것을 이용)</li>
  <li>접두어(-1(npos)이 아니면)이면 false를 반환한다.</li>
  <li>접두어가 없어 반복문이 끝나면 true를 반환한다.<br />
<br /><br /></li>
</ol>

<h2 id="3-해결코드">3. 해결코드</h2>
<h3 id="c">[C++]</h3>
<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
</pre></td><td class="rouge-code"><pre><span class="cp">#include &lt;string&gt;
#include &lt;vector&gt;
#include &lt;set&gt;
</span>
<span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>

<span class="kt">bool</span> <span class="nf">solution</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">phone_book</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">set</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">phone_numbers</span><span class="p">;</span>
    
    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">phone_book</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
        <span class="n">phone_numbers</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="n">phone_book</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>

    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">phone_book</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">set</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;::</span><span class="n">iterator</span> <span class="n">itup</span> <span class="o">=</span> <span class="n">phone_numbers</span><span class="p">.</span><span class="n">upper_bound</span><span class="p">(</span><span class="n">phone_book</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">itup</span> <span class="o">==</span> <span class="n">phone_numbers</span><span class="p">.</span><span class="n">end</span><span class="p">())</span> <span class="k">continue</span><span class="p">;</span>
        <span class="k">if</span> <span class="p">((</span><span class="o">*</span><span class="n">itup</span><span class="p">).</span><span class="n">find</span><span class="p">(</span><span class="n">phone_book</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="o">!=</span> <span class="n">string</span><span class="o">::</span><span class="n">npos</span><span class="p">)</span>
            <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
    <span class="p">}</span>
    
    <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre></div></div>
<p><br /><br /><br /></p>

<h2 id="4-해결능력up-깊이-생각해보기">4. 해결능력UP, 깊이 생각해보기</h2>
<ul>
  <li>해시를 사용해서 푼 것이 맞나?</li>
  <li>정렬을 사용해서 풀 수도 있다!
<br /><br /><br /></li>
</ul>

<h2 id="5-참고해서-문제해결-٩-ᐛ-و">5. 참고해서 문제해결 ٩( ᐛ )و</h2>
<ul>
  <li>[C++ 공식문서] std:set:upper_bound <a href="http://www.cplusplus.com/reference/set/set/upper_bound/">http://www.cplusplus.com/reference/set/set/upper_bound/</a></li>
  <li>[C++ 레퍼런스 - string 의 find 함수] <a href="https://modoocode.com/241">https://modoocode.com/241</a><br />
string.find() 함수는 찾고자하는 문자(열)이 해당 문자열에 없을경우 string::npos를 반환
<br /><br /><br /></li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre></td><td class="rouge-code"><pre>출처: 프로그래머스 코딩 테스트 연습, https://programmers.co.kr/learn/challenges
</pre></td></tr></tbody></table></code></pre></div></div>
:ET